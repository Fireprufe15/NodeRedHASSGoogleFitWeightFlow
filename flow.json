[
  {
    "id": "6196697d07054a06",
    "type": "tab",
    "label": "GoogleFitWeightFlow",
    "disabled": false,
    "info": "",
    "env": []
  },
  {
    "id": "bb962140bd167c6e",
    "type": "server-state-changed",
    "z": "6196697d07054a06",
    "name": "WeightStateChange",
    "server": "d5d6c7dfc1e29ed7",
    "version": 4,
    "exposeToHomeAssistant": false,
    "haConfig": [
      {
        "property": "name",
        "value": ""
      },
      {
        "property": "icon",
        "value": ""
      }
    ],
    "entityidfilter": "sensor.mg_potgieter_weight",
    "entityidfiltertype": "exact",
    "outputinitially": false,
    "state_type": "str",
    "haltifstate": "",
    "halt_if_type": "str",
    "halt_if_compare": "is",
    "outputs": 1,
    "output_only_on_state_change": false,
    "for": "0",
    "forType": "num",
    "forUnits": "minutes",
    "ignorePrevStateNull": false,
    "ignorePrevStateUnknown": false,
    "ignorePrevStateUnavailable": false,
    "ignoreCurrentStateUnknown": false,
    "ignoreCurrentStateUnavailable": false,
    "outputProperties": [
      {
        "property": "payload",
        "propertyType": "msg",
        "value": "",
        "valueType": "entityState"
      },
      {
        "property": "data",
        "propertyType": "msg",
        "value": "",
        "valueType": "eventData"
      },
      {
        "property": "topic",
        "propertyType": "msg",
        "value": "",
        "valueType": "triggerId"
      }
    ],
    "x": 130,
    "y": 520,
    "wires": [["2fd3750fc4568912"]]
  },
  {
    "id": "4950c18bee87d872",
    "type": "change",
    "z": "6196697d07054a06",
    "name": "Store weight",
    "rules": [
      {
        "t": "set",
        "p": "current_weight",
        "pt": "flow",
        "to": "payload",
        "tot": "msg"
      }
    ],
    "action": "",
    "property": "",
    "from": "",
    "to": "",
    "reg": false,
    "x": 370,
    "y": 520,
    "wires": [["4c2fd26622d9cb6f"]]
  },
  {
    "id": "2fd3750fc4568912",
    "type": "function",
    "z": "6196697d07054a06",
    "name": "Parse to float",
    "func": "msg.payload = parseFloat(msg.payload);\nreturn msg;",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 270,
    "y": 460,
    "wires": [["4950c18bee87d872"]]
  },
  {
    "id": "4c2fd26622d9cb6f",
    "type": "function",
    "z": "6196697d07054a06",
    "name": "Prepare Token Request",
    "func": "// --- Configuration ---\nconst clientId = {CLIENT ID}; // <-- PASTE YOUR CLIENT ID HERE\nconst clientSecret = {CLIENT SECRET}; // <-- PASTE YOUR CLIENT SECRET HERE\nconst refreshToken = {REFRESH TOKEN}; // <-- PASTE YOUR REFRESH TOKEN HERE\n// ---------------------\n\nmsg.payload = {\n    client_id: clientId,\n    client_secret: clientSecret,\n    refresh_token: refreshToken,\n    grant_type: \"refresh_token\"\n};\n\nmsg.url = \"https://oauth2.googleapis.com/token\";\nmsg.method = \"POST\";\nmsg.headers = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\" // Important for the token endpoint\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 170,
    "y": 620,
    "wires": [["48cbce689de0ce22"]]
  },
  {
    "id": "48cbce689de0ce22",
    "type": "http request",
    "z": "6196697d07054a06",
    "name": "",
    "method": "use",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 390,
    "y": 620,
    "wires": [["4f76caa4eb18222f"]]
  },
  {
    "id": "4f76caa4eb18222f",
    "type": "function",
    "z": "6196697d07054a06",
    "name": "Prepare Fit API Payload",
    "func": "// --- Configuration ---\n// Create a unique data source ID. You can customize the app name part.\n// It should be consistent for subsequent updates to the same data stream.\nconst dataSourceId = {DATA SOURCE ID};\n// ---------------------\n\n// Retrieve the stored weight and the new access token\nconst weightKg = parseFloat(flow.get(\"current_weight\")); // Get weight from flow context\nconst accessToken = msg.payload.access_token;\n\nif (isNaN(weightKg)) {\n    node.error(\"Invalid weight value received: \" + flow.get(\"current_weight\"));\n    return null; // Stop the flow if weight is not a number\n}\n\nif (!accessToken) {\n    node.error(\"Failed to get access token.\", msg);\n    return null; // Stop the flow if no access token\n}\n\n// Get current time in milliseconds and convert to nanoseconds\nconst nowMillis = Date.now();\nconst nowNanos = nowMillis * 1000000;\n\n// Google Fit API requires a start and end time for the data point (even if instantaneous)\n// We use the same time for both for a single measurement.\nconst startTimeNanos = nowNanos;\nconst endTimeNanos = nowNanos;\n\n// Construct the dataset patch URL\n// The timespan in the URL should encompass the points within the payload\nmsg.url = `https://www.googleapis.com/fitness/v1/users/me/dataSources/${dataSourceId}/datasets/${startTimeNanos}-${endTimeNanos}`;\n\n// Set the HTTP method for patching the dataset\nmsg.method = \"PATCH\";\n\n// Set the required headers, including the Authorization bearer token\nmsg.headers = {\n    \"Authorization\": \"Bearer \" + accessToken,\n    \"Content-Type\": \"application/json;encoding=utf-8\"\n};\n\n// Construct the payload according to Google Fit API specification\nmsg.payload = {\n    \"dataSourceId\": dataSourceId,\n    \"minStartTimeNs\": startTimeNanos,\n    \"maxEndTimeNs\": endTimeNanos,\n    \"point\": [\n        {\n            \"startTimeNanos\": startTimeNanos,\n            \"endTimeNanos\": endTimeNanos,\n            \"dataTypeName\": \"com.google.weight\",\n            \"value\": [\n                {\n                    \"fpVal\": weightKg // Use fpVal for floating point values (weight)\n                }\n            ]\n        }\n    ]\n};\n\nnode.log(\"Prepared Google Fit Payload: \" + JSON.stringify(msg.payload));\nreturn msg;",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 170,
    "y": 720,
    "wires": [["bff256bf2030fbe8"]]
  },
  {
    "id": "bff256bf2030fbe8",
    "type": "http request",
    "z": "6196697d07054a06",
    "name": "",
    "method": "use",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 430,
    "y": 720,
    "wires": [["493e2350b7c34cfc"]]
  },
  {
    "id": "493e2350b7c34cfc",
    "type": "debug",
    "z": "6196697d07054a06",
    "name": "debug 1",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "statusVal": "",
    "statusType": "auto",
    "x": 640,
    "y": 720,
    "wires": []
  },
  {
    "id": "d5d6c7dfc1e29ed7",
    "type": "server",
    "name": "Home Assistant",
    "version": 5,
    "addon": false,
    "rejectUnauthorizedCerts": true,
    "ha_boolean": "y|yes|true|on|home|open",
    "connectionDelay": true,
    "cacheJson": true,
    "heartbeat": true,
    "heartbeatInterval": "30",
    "areaSelector": "friendlyName",
    "deviceSelector": "friendlyName",
    "entitySelector": "friendlyName",
    "statusSeparator": ": ",
    "statusYear": "hidden",
    "statusMonth": "short",
    "statusDay": "numeric",
    "statusHourCycle": "default",
    "statusTimeFormat": "h:m",
    "enableGlobalContextStore": true
  }
]
